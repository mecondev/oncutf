# Refactoring & Optimization Plan

**Date:** 2025-12-19  
**Author:** AI Assistant  
**Status:** DRAFT — Awaiting Review

---

## 1. Executive Summary

This document outlines a comprehensive refactoring plan for the `oncutf` codebase. The codebase has already undergone significant restructuring — code now resides in the `oncutf/` package with organized subdirectories (`controllers/`, `core/`, `domain/`, `models/`, `modules/`, `services/`, `ui/`, `utils/`).

### Primary Goals
1. **Performance** — Reduce startup time, optimize metadata loading, enhance cache efficiency
2. **Code Clarity** — Split remaining oversized classes, improve separation of concerns
3. **GUI Stability** — Implement defensive programming, global error boundaries, thread safety

### Key Metrics

| File | Size | Lines (est.) | Issue |
|------|------|--------------|-------|
| `core/unified_metadata_manager.py` | 91KB | ~2,300 | Monolithic — handles reading, writing, caching |
| `core/event_handler_manager.py` | 63KB | ~1,600 | Handles all UI events — no domain separation |
| `ui/main_window.py` | 56KB | ~1,400 | Large but acceptable facade |
| `core/database_manager.py` | 54KB | ~1,400 | Complex — consider splitting |
| `core/unified_rename_engine.py` | 46KB | ~1,200 | Consider splitting by responsibility |

The `core/` directory still contains **64 files** — grouping by subdomain would improve maintainability.

---

## 2. Structural Refactoring

### 2.1 Split `core/` into Subdirectories

**Current State:** 64 files in flat structure  
**Proposed Structure:**

```
core/
├── cache/                    # Cache management
│   ├── advanced_cache_manager.py
│   ├── persistent_hash_cache.py
│   └── persistent_metadata_cache.py
├── database/                 # Database operations
│   ├── database_manager.py
│   └── optimized_database_manager.py
├── drag/                     # Drag & drop operations
│   ├── drag_cleanup_manager.py
│   ├── drag_manager.py
│   └── drag_visual_manager.py
├── events/                   # Event handling (split from event_handler_manager)
│   ├── file_event_handlers.py
│   ├── ui_event_handlers.py
│   └── context_menu_handlers.py
├── hash/                     # Hash operations
│   ├── hash_manager.py
│   ├── hash_operations_manager.py
│   ├── hash_worker.py
│   └── parallel_hash_worker.py
├── initialization/           # Startup logic
│   ├── initialization_manager.py
│   ├── initialization_orchestrator.py
│   └── initialization_worker.py
├── metadata/                 # Metadata operations (split from unified_metadata_manager)
│   ├── metadata_reader.py
│   ├── metadata_writer.py
│   ├── metadata_cache_service.py
│   └── companion_handler.py
├── rename/                   # Rename operations
│   ├── rename_manager.py
│   ├── rename_history_manager.py
│   └── unified_rename_engine.py
├── selection/                # Selection management
│   ├── selection_manager.py
│   └── selection_store.py
└── ui_managers/              # UI-related managers
    ├── ui_manager.py
    ├── column_manager.py
    ├── splitter_manager.py
    └── status_manager.py
```

### 2.2 Split God Classes

#### 2.2.1 `unified_metadata_manager.py` (91KB) → 4 Modules

| New Module | Responsibility |
|------------|----------------|
| `MetadataReader` | Load metadata from files using ExifTool |
| `MetadataWriter` | Write/update metadata to files |
| `MetadataCacheService` | In-memory and persistent cache operations |
| `CompanionMetadataHandler` | Handle sidecar/companion file metadata |

#### 2.2.2 `event_handler_manager.py` (63KB) → 3 Modules

| New Module | Responsibility |
|------------|----------------|
| `FileEventHandlers` | Browse, folder import, file operations |
| `UIEventHandlers` | Context menus, header toggles, splitter moves |
| `ContextMenuHandlers` | Right-click menu logic (currently ~400 lines in one method) |

---

## 3. Performance Optimization

### 3.1 Startup Time Reduction

**Actions:**
- [ ] Profile initialization to identify bottlenecks
- [ ] Lazy-load non-essential managers
- [ ] Defer database connection until first use
- [ ] Use `QTimer.singleShot(0, ...)` for non-critical post-startup tasks

### 3.2 ExifTool Batching

**Current State:** Uses `-stay_open` mode ✓  
**Improvements:**
- [ ] Verify batch size is optimal
- [ ] Add request coalescing for rapid successive calls
- [ ] Implement request prioritization (UI-blocking vs background)

### 3.3 Cache Strategy Review

**Files to audit:**
- `core/advanced_cache_manager.py`
- `core/persistent_metadata_cache.py`
- `utils/metadata_cache_helper.py`

**Actions:**
- [ ] Ensure L1 (memory) → L2 (disk) cache hierarchy
- [ ] Review cache invalidation logic
- [ ] Add cache hit/miss metrics logging for profiling

### 3.4 GUI Responsiveness

- [ ] Audit for long-running operations on main thread
- [ ] Verify signal debouncing on high-frequency signals
- [ ] Review `processEvents()` calls — can cause reentrancy bugs

---

## 4. GUI Error Reduction

### 4.1 Global Error Boundary

**Location:** `main.py`

**Implementation:**
```python
def global_exception_handler(exc_type, exc_value, exc_tb):
    logger.critical("Unhandled exception", exc_info=(exc_type, exc_value, exc_tb))
    # Show user-friendly notification instead of crashing
    # Attempt graceful recovery or offer restart
    
sys.excepthook = global_exception_handler
```

### 4.2 Defensive Widget Programming

**Pattern to enforce in `ui/widgets/`:**
```python
# Before (unsafe)
value = file_item.metadata.get("Date")

# After (safe)
value = getattr(file_item, 'metadata', {}).get("Date", "")
```

### 4.3 Qt Object Lifecycle

**Problem:** `RuntimeError: wrapped C/C++ object has been deleted`

**Solutions:**
- Use `QPointer` for potentially deleted objects
- Check `isValid()` / `is not None` before operations
- Use `deleteLater()` instead of `del` or `close()`

---

## 5. Implementation Roadmap

### Phase 1: Foundation (Days 1-2)
- [ ] Implement global error boundary in `main.py`
- [ ] Create subdirectory structure under `core/`
- [ ] Run existing tests — ensure no regressions

### Phase 2: Core Refactoring (Days 3-6)
- [ ] Split `unified_metadata_manager.py` into 4 modules
- [ ] Split `event_handler_manager.py` into 3 modules
- [ ] Update all imports
- [ ] Run tests after each split

### Phase 3: Performance (Days 7-9)
- [ ] Profile startup time
- [ ] Optimize cache strategy
- [ ] Add debouncing where missing

### Phase 4: Polish (Days 10-12)
- [ ] Add defensive programming patterns
- [ ] Fix Qt object lifecycle issues
- [ ] Final testing and documentation

---

## 6. Verification Plan

### Automated Tests
```bash
# Run all tests
pytest tests/ -v

# Run with coverage
pytest tests/ --cov=oncutf --cov-report=term-missing
```

### Manual Verification
1. **Startup Test:** Application starts without errors in < 3 seconds
2. **File Loading:** Load 100+ files, verify no UI freezes
3. **Metadata Operations:** Load, edit, save metadata without crashes
4. **Drag & Drop:** All drag operations work smoothly
5. **Error Handling:** Force errors and verify graceful recovery

---

## 7. Success Metrics

| Metric | Current | Target |
|--------|---------|--------|
| Startup Time | Unknown | < 2s |
| Max Module Size | 91KB | < 30KB |
| Unhandled Exceptions | Unknown | 0 |
| Test Coverage | Unknown | > 80% |

---

## 8. Risk Assessment

| Risk | Mitigation |
|------|------------|
| Breaking existing functionality | Run tests after each change |
| Import cycle issues | Use lazy imports where needed |
| Performance regression | Profile before/after each phase |

---

## 9. Existing Test Infrastructure

**Test Location:** `tests/` (76 files)

```bash
# Verify existing tests still pass
pytest tests/ -v --tb=short
```

---

**Next Steps:** Review this plan and approve before proceeding to Phase 1.
